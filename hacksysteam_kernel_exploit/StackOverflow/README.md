# part 1. StackOverflow
[hacksysteam site]: https://rootkits.xyz/blog/2017/08/kernel-stack-overflow/

## 1. Analysis
제공 된 HEVD drive의 소스코드 중 StackOverflow.c 코드를 보면 vulnerable code 와 secure code가 나뉘어 있다.

\`

        #ifdef SECURE
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));

        #else
        DbgPrint("[+] Triggering Stack Overflow\n");

        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
\`

* RtlCopyMemory(argv1.argv2,argv3); 은 argv3에 지정 한 길이만큼 argv2의 내용을 argv1의 주소에 Copy한다.
* Secure Note : argv3을 Copy 될 버퍼의 Size만큼 지정했기 때문에 Overflow에 안전하다.
* Vulnerability Note : Copy 될 Size를 UserBuffer(argv2)의 Size 만큼 지정해주면, 사용자가 입력한 Data의 length 만큼 Copy 되어 Overflow가 발생할 수 있다. 


스택 오버플로 모듈이 어떻게 그리고 어디서 트리거되는지 이해하기 위해 IDA Pro의 드라이버를 분석해 봅시다.

![1](https://user-images.githubusercontent.com/35731091/45018850-e1b94100-b065-11e8-9d51-ffc939c23413.png)

흐름을 보았을 때, IrpDeviceIoCtlHandler() function에서 StackOverflowIoctlHandler()를 Call 하는 것을 볼 수 있습니다.
